# 第四章 变量、作用域与内存

## 4.1 原始值与引用值

ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。 原始值（primitive value）就是
最简单的数据， 引用值（reference value）则是由多个值构成的对象。  

保存原始值的变量是按值（by value）访问的，因为操作的就是存储在变量中的实际值。  

保存引用值的变量是按引用（by reference）访问的 ，在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。  

### 动态属性

对于引用值而言，可以随时添加、修改和删除其属性和方法。而原始值则不能拥有属性。  

```javascript
let person = new Object();
person.name = "Nicholas";
console.log(person.name); // "Nicholas"

let name = "Nicholas";
name.age = 27;
console.log(name.age); // undefined
```

### 复制值

除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。  

在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。  

在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象。

```javascript
let obj1 = new Object();
let obj2 = obj1;
obj1.name = "Nicholas";
console.log(obj2.name); // "Nicholas"
```

### 传递参数

ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。  

### 确定类型

`typeof` 操作符是判断一个变量是否为字符串、数值、布尔值、undefined或函数的最好方式。  

```javascript
let s = "Nicholas";
let b = true;
let i = 22;
let u;
let n = null;
let o = new Object();
let p = function(){};
console.log(typeof s); // string
console.log(typeof i); // number
console.log(typeof b); // boolean
console.log(typeof u); // undefined
console.log(typeof n); // object
console.log(typeof o); // object
console.log(typeof p); // function
```

`instanceof`运算符适合判断一个变量是否为某个引用类型的实例。

```javascript
console.log(person instanceof Object); // 变量 person 是 Object 吗？
console.log(colors instanceof Array); // 变量 colors 是 Array 吗？
console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？
```

## 4.2 执行上下文与作用域

变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。  

全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文是 window 对象，所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。  

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。 ECMAScript程序的执行流就是通过这个上下文栈进行控制的。  

上下文中的代码在执行的时候，会创建变量对象的一个**作用域链**（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端，而全局上下文的变量对象始终是作用域链的最后一个变量对象。  

**代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的**。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）  

### 作用域链增强

虽然执行上下文主要有全局上下文和函数上下文两种（`eval()`调用内部存在第三种上下文） 但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。

*  with语句

  with语句会向作用域链前端添加指定的对象。

  ```javascript
  function buildUrl() {
      let qs = "?debug=true";
      with(location){
          let url = href + qs; // 这里的href实际上引用的是location.href
      }
      return url;
  }
  ```

* try/catch语句的catch块

  catch语句会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。

### 变量声明

#### 使用`var`的函数作用域声明

在使用 var 声明变量时，变量会被自动添加到最接近的上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文。

> 未经声明而初始化变量是极度不推荐的行为。在严格模式下，未经声明就初始化变量会报错。
>

var 声明存在「变量提升（hoisting）」的现象，即var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。

#### 使用`let`的块级作用域声明

* let 关键字的作用域是块级的，块级作用域由最近的一对包含花括号{}界定。
* let在同一作用域下不能重复声明。
* 严格来讲，let 在 JavaScript 运行时中也会被提升，但由于“暂时性死区”（temporal dead zone）的缘故，实际上不能在声明之前使用 let 变量。

#### 使用const的块级作用域常量声明

* 使用 const 声明的变量必须同时初始化为某个值。

* 一经声明，在其生命周期的任何时候都不能再重新赋予新值。

  const 声明只应用到顶级原语或者对象。即赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。

  可以使用`Object.freeze()`来让整个对象都不能修改。

* const 除了要遵循以上规则，其他方面与 let 声明一致。

#### 标识符查找

标识符查找开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则**搜索停止**，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。

## 4.3 垃圾回收

JavaScript通过自动内存管理实现内存分配和闲置资源回收。垃圾回收过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。

### 标记清理

标记清理（mark-and-sweep）是JavaScript **最常用**的垃圾回收策略。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。

垃圾回收程序运行的时候，会标记内存中存储的所有变量（标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

### 引用计数

引用计数（reference counting）是另一种没那么常用的垃圾回收策略。

其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。

循环引用的情况下，相互引用的变量的引用数永远都不会变成0，导致内存永远不会被释放。

```javascript
function problem() {
	let objectA = new Object();
  let objectB = new Object();
  // 循环引用
  objectA.someOtherObject = objectB;
  objectB.anotherObject = objectA;
}
```

> IE8及以前的版本，BOM 和 DOM 中的对象是 C++ 实现的组件对象模型（COM，Component Object Model）对象，而 COM 对象使用引用计数实现垃圾回收。为避免循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接。

### 性能

垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。

现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。

> 在某些浏览器中支持主动触发垃圾回收，但不推荐这么做。

### 内存管理

分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的则更少。这更多出于安全考虑而不是别的，就是为了避免运行大量 JavaScript 的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。

将内存占用量保持在一个较小的值可以让页面性能更好。优化内存h占用的最佳手段就是保证在执行代码时**只保存必要的数据**。如果数据不再必要，那么把它设置为 null，从而释放其引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用，不需要显式处理。

1. 通过const和let声明提升性能

   const 和 let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。

2. 隐藏类和删除操作

   运行期间，Chrome的 V8 引擎会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好。

   优化策略是避免 JavaScript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在构造函数中一次性声明所有属性。

   ```javascript
   function Article(opt_author) {
     this.title = 'Inauguration Ceremony Features Kazoo Band';
     this.author = opt_author;
   }
   // 这两个实例可以共享一个隐藏类
   let a1 = new Article();
   let a2 = new Article('Jake');
   // 下面操作会增加隐藏类
   a1.author = 'Scott';
   ```

   而动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为 null。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。

3. 内存泄漏

   JavaScript 中的内存泄漏大部分是由不合理的引用导致的。

   * 意外声明全局变量

   * 定时器的回调通过闭包引用了外部变量可能会造成内存泄露

     ```javascript
     let name = 'Jake';
     setInterval(() => {
       console.log(name);
     }, 100);
     ```

   * 闭包也容易造成内存泄漏

     ```javascript
     let outer = function() {
     	let name = 'Jake';
     	return function() {
         return name;
       };
     };
     ```

4. 静态分配与对象池

   为了提升 JavaScript 性能，一个关键问题就是**如何减少浏览器执行垃圾回收的次数**。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。

   浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。因此需要尽量减少对象的创建量，其中一个策略是使用**对象池**。在初始化时，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。

   如果对象池只按需分配对象（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。如果这个对象池的数据结构使用数组实现，则尽可能在初始化时就创建一个大小够用的数组，从而避免先删除再创建的操作而导致额外的垃圾回收。